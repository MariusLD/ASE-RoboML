/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.mydsl2.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl2.services.MyDslGrammarAccess;
import robot.Affectation;
import robot.And;
import robot.BooleanExp;
import robot.BooleanType;
import robot.CM;
import robot.CallFunction;
import robot.CallVariable;
import robot.ComparaisonAri;
import robot.ComparaisonDistance;
import robot.ComparaisonTime;
import robot.DeclarationVariable;
import robot.DirectionCommand;
import robot.DistanceSensorCommand;
import robot.Equals;
import robot.Function;
import robot.IF;
import robot.LOOP;
import robot.MultDiv;
import robot.MultDivDistance;
import robot.MultDiveTime;
import robot.Not;
import robot.NumberType;
import robot.Or;
import robot.PlusMinus;
import robot.PlusMinusDistance;
import robot.PlusMinusTime;
import robot.PrimaryExprAri;
import robot.PrimaryExprBool;
import robot.PrimaryExprDistance;
import robot.PrimaryExprTime;
import robot.Robot;
import robot.RobotPackage;
import robot.RotateCommand;
import robot.SpeedCommand;
import robot.Time;
import robot.TimeSensorCommand;
import robot.mm;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotPackage.AFFECTATION:
				sequence_Affectation(context, (Affectation) semanticObject); 
				return; 
			case RobotPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobotPackage.BOOLEAN_EXP:
				sequence_BooleanExp_Impl(context, (BooleanExp) semanticObject); 
				return; 
			case RobotPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case RobotPackage.CM:
				sequence_CM(context, (CM) semanticObject); 
				return; 
			case RobotPackage.CALL_FUNCTION:
				sequence_CallFunction(context, (CallFunction) semanticObject); 
				return; 
			case RobotPackage.CALL_VARIABLE:
				sequence_CallVariable(context, (CallVariable) semanticObject); 
				return; 
			case RobotPackage.COMPARAISON_ARI:
				sequence_ComparaisonAri(context, (ComparaisonAri) semanticObject); 
				return; 
			case RobotPackage.COMPARAISON_DISTANCE:
				sequence_ComparaisonDistance(context, (ComparaisonDistance) semanticObject); 
				return; 
			case RobotPackage.COMPARAISON_TIME:
				sequence_ComparaisonTime(context, (ComparaisonTime) semanticObject); 
				return; 
			case RobotPackage.DECLARATION_VARIABLE:
				sequence_DeclarationVariable(context, (DeclarationVariable) semanticObject); 
				return; 
			case RobotPackage.DIRECTION_COMMAND:
				sequence_DirectionCommand(context, (DirectionCommand) semanticObject); 
				return; 
			case RobotPackage.DISTANCE_SENSOR_COMMAND:
				sequence_DistanceSensorCommand(context, (DistanceSensorCommand) semanticObject); 
				return; 
			case RobotPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case RobotPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case RobotPackage.IF:
				sequence_IF(context, (IF) semanticObject); 
				return; 
			case RobotPackage.LOOP:
				sequence_LOOP(context, (LOOP) semanticObject); 
				return; 
			case RobotPackage.MULT_DIV:
				sequence_MultDiv(context, (MultDiv) semanticObject); 
				return; 
			case RobotPackage.MULT_DIV_DISTANCE:
				sequence_MultDivDistance(context, (MultDivDistance) semanticObject); 
				return; 
			case RobotPackage.MULT_DIVE_TIME:
				sequence_MultDiveTime(context, (MultDiveTime) semanticObject); 
				return; 
			case RobotPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case RobotPackage.NUMBER_TYPE:
				sequence_NumberType(context, (NumberType) semanticObject); 
				return; 
			case RobotPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobotPackage.PLUS_MINUS:
				sequence_PlusMinus(context, (PlusMinus) semanticObject); 
				return; 
			case RobotPackage.PLUS_MINUS_DISTANCE:
				sequence_PlusMinusDistance(context, (PlusMinusDistance) semanticObject); 
				return; 
			case RobotPackage.PLUS_MINUS_TIME:
				sequence_PlusMinusTime(context, (PlusMinusTime) semanticObject); 
				return; 
			case RobotPackage.PRIMARY_EXPR_ARI:
				sequence_PrimaryExprAri(context, (PrimaryExprAri) semanticObject); 
				return; 
			case RobotPackage.PRIMARY_EXPR_BOOL:
				sequence_PrimaryExprBool(context, (PrimaryExprBool) semanticObject); 
				return; 
			case RobotPackage.PRIMARY_EXPR_DISTANCE:
				sequence_PrimaryExprDistance(context, (PrimaryExprDistance) semanticObject); 
				return; 
			case RobotPackage.PRIMARY_EXPR_TIME:
				sequence_PrimaryExprTime(context, (PrimaryExprTime) semanticObject); 
				return; 
			case RobotPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case RobotPackage.ROTATE_COMMAND:
				sequence_RotateCommand(context, (RotateCommand) semanticObject); 
				return; 
			case RobotPackage.SPEED_COMMAND:
				sequence_SpeedCommand(context, (SpeedCommand) semanticObject); 
				return; 
			case RobotPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case RobotPackage.TIME_SENSOR_COMMAND:
				sequence_TimeSensorCommand(context, (TimeSensorCommand) semanticObject); 
				return; 
			case RobotPackage.MM:
				sequence_mm(context, (mm) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Affectation
	 *     ExpressionBase returns Affectation
	 *     Affectation returns Affectation
	 *
	 * Constraint:
	 *     (expressionbase+=ExpressionBase expressionbase+=ExpressionBase* callvariable=CallVariable?)
	 * </pre>
	 */
	protected void sequence_Affectation(ISerializationContext context, Affectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns And
	 *     ExpressionBase returns And
	 *     Expression returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     {And}
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns BooleanExp
	 *     ExpressionBase returns BooleanExp
	 *     Expression returns BooleanExp
	 *     BooleanExp_Impl returns BooleanExp
	 *
	 * Constraint:
	 *     {BooleanExp}
	 * </pre>
	 */
	protected void sequence_BooleanExp_Impl(ISerializationContext context, BooleanExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     value?='value'?
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns CM
	 *     Distance returns CM
	 *     CM returns CM
	 *
	 * Constraint:
	 *     distance=EDouble?
	 * </pre>
	 */
	protected void sequence_CM(ISerializationContext context, CM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns CallFunction
	 *     Call returns CallFunction
	 *     ExpressionBase returns CallFunction
	 *     CallFunction returns CallFunction
	 *
	 * Constraint:
	 *     {CallFunction}
	 * </pre>
	 */
	protected void sequence_CallFunction(ISerializationContext context, CallFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns CallVariable
	 *     Call returns CallVariable
	 *     ExpressionBase returns CallVariable
	 *     CallVariable returns CallVariable
	 *
	 * Constraint:
	 *     {CallVariable}
	 * </pre>
	 */
	protected void sequence_CallVariable(ISerializationContext context, CallVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns ComparaisonAri
	 *     ExpressionBase returns ComparaisonAri
	 *     Expression returns ComparaisonAri
	 *     ComparaisonAri returns ComparaisonAri
	 *
	 * Constraint:
	 *     {ComparaisonAri}
	 * </pre>
	 */
	protected void sequence_ComparaisonAri(ISerializationContext context, ComparaisonAri semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns ComparaisonDistance
	 *     ExpressionBase returns ComparaisonDistance
	 *     Expression returns ComparaisonDistance
	 *     ComparaisonDistance returns ComparaisonDistance
	 *
	 * Constraint:
	 *     {ComparaisonDistance}
	 * </pre>
	 */
	protected void sequence_ComparaisonDistance(ISerializationContext context, ComparaisonDistance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns ComparaisonTime
	 *     ExpressionBase returns ComparaisonTime
	 *     Expression returns ComparaisonTime
	 *     ComparaisonTime returns ComparaisonTime
	 *
	 * Constraint:
	 *     {ComparaisonTime}
	 * </pre>
	 */
	protected void sequence_ComparaisonTime(ISerializationContext context, ComparaisonTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns DeclarationVariable
	 *     DeclarationVariable returns DeclarationVariable
	 *
	 * Constraint:
	 *     (nom=EString? expressionbase=ExpressionBase? type=TypeClass)
	 * </pre>
	 */
	protected void sequence_DeclarationVariable(ISerializationContext context, DeclarationVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns DirectionCommand
	 *     DirectionCommand returns DirectionCommand
	 *
	 * Constraint:
	 *     distance=Distance
	 * </pre>
	 */
	protected void sequence_DirectionCommand(ISerializationContext context, DirectionCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.DIRECTION_COMMAND__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.DIRECTION_COMMAND__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectionCommandAccess().getDistanceDistanceParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns DistanceSensorCommand
	 *     DistanceSensorCommand returns DistanceSensorCommand
	 *
	 * Constraint:
	 *     {DistanceSensorCommand}
	 * </pre>
	 */
	protected void sequence_DistanceSensorCommand(ISerializationContext context, DistanceSensorCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Equals
	 *     ExpressionBase returns Equals
	 *     Expression returns Equals
	 *     Equals returns Equals
	 *
	 * Constraint:
	 *     {Equals}
	 * </pre>
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     ((instruction+=Instruction instruction+=Instruction*)? (parameters+=TypeClass parameters+=TypeClass*)? return=TypeClass?)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns IF
	 *     IF returns IF
	 *
	 * Constraint:
	 *     ((instruction+=Instruction instruction+=Instruction*)? expression=Expression)
	 * </pre>
	 */
	protected void sequence_IF(ISerializationContext context, IF semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns LOOP
	 *     LOOP returns LOOP
	 *
	 * Constraint:
	 *     ((instruction+=Instruction instruction+=Instruction*)? expression=Expression)
	 * </pre>
	 */
	protected void sequence_LOOP(ISerializationContext context, LOOP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns MultDivDistance
	 *     ExpressionBase returns MultDivDistance
	 *     Expression returns MultDivDistance
	 *     MultDivDistance returns MultDivDistance
	 *
	 * Constraint:
	 *     {MultDivDistance}
	 * </pre>
	 */
	protected void sequence_MultDivDistance(ISerializationContext context, MultDivDistance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns MultDiv
	 *     ExpressionBase returns MultDiv
	 *     Expression returns MultDiv
	 *     MultDiv returns MultDiv
	 *
	 * Constraint:
	 *     {MultDiv}
	 * </pre>
	 */
	protected void sequence_MultDiv(ISerializationContext context, MultDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns MultDiveTime
	 *     ExpressionBase returns MultDiveTime
	 *     Expression returns MultDiveTime
	 *     MultDiveTime returns MultDiveTime
	 *
	 * Constraint:
	 *     {MultDiveTime}
	 * </pre>
	 */
	protected void sequence_MultDiveTime(ISerializationContext context, MultDiveTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Not
	 *     ExpressionBase returns Not
	 *     Expression returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     {Not}
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns NumberType
	 *     NumberType returns NumberType
	 *
	 * Constraint:
	 *     value=EDouble?
	 * </pre>
	 */
	protected void sequence_NumberType(ISerializationContext context, NumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Or
	 *     ExpressionBase returns Or
	 *     Expression returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     {Or}
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PlusMinusDistance
	 *     ExpressionBase returns PlusMinusDistance
	 *     Expression returns PlusMinusDistance
	 *     PlusMinusDistance returns PlusMinusDistance
	 *
	 * Constraint:
	 *     {PlusMinusDistance}
	 * </pre>
	 */
	protected void sequence_PlusMinusDistance(ISerializationContext context, PlusMinusDistance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PlusMinusTime
	 *     ExpressionBase returns PlusMinusTime
	 *     Expression returns PlusMinusTime
	 *     PlusMinusTime returns PlusMinusTime
	 *
	 * Constraint:
	 *     {PlusMinusTime}
	 * </pre>
	 */
	protected void sequence_PlusMinusTime(ISerializationContext context, PlusMinusTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PlusMinus
	 *     ExpressionBase returns PlusMinus
	 *     Expression returns PlusMinus
	 *     PlusMinus returns PlusMinus
	 *
	 * Constraint:
	 *     {PlusMinus}
	 * </pre>
	 */
	protected void sequence_PlusMinus(ISerializationContext context, PlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PrimaryExprAri
	 *     ExpressionBase returns PrimaryExprAri
	 *     Expression returns PrimaryExprAri
	 *     PrimaryExprAri returns PrimaryExprAri
	 *
	 * Constraint:
	 *     (type=TypeClass? call=Call?)
	 * </pre>
	 */
	protected void sequence_PrimaryExprAri(ISerializationContext context, PrimaryExprAri semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PrimaryExprBool
	 *     ExpressionBase returns PrimaryExprBool
	 *     Expression returns PrimaryExprBool
	 *     PrimaryExprBool returns PrimaryExprBool
	 *
	 * Constraint:
	 *     (type=TypeClass? call=Call?)
	 * </pre>
	 */
	protected void sequence_PrimaryExprBool(ISerializationContext context, PrimaryExprBool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PrimaryExprDistance
	 *     ExpressionBase returns PrimaryExprDistance
	 *     Expression returns PrimaryExprDistance
	 *     PrimaryExprDistance returns PrimaryExprDistance
	 *
	 * Constraint:
	 *     distance=Distance?
	 * </pre>
	 */
	protected void sequence_PrimaryExprDistance(ISerializationContext context, PrimaryExprDistance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns PrimaryExprTime
	 *     ExpressionBase returns PrimaryExprTime
	 *     Expression returns PrimaryExprTime
	 *     PrimaryExprTime returns PrimaryExprTime
	 *
	 * Constraint:
	 *     time=Time?
	 * </pre>
	 */
	protected void sequence_PrimaryExprTime(ISerializationContext context, PrimaryExprTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (function+=Function function+=Function*)?
	 * </pre>
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns RotateCommand
	 *     RotateCommand returns RotateCommand
	 *
	 * Constraint:
	 *     angle=EDouble?
	 * </pre>
	 */
	protected void sequence_RotateCommand(ISerializationContext context, RotateCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns SpeedCommand
	 *     SpeedCommand returns SpeedCommand
	 *
	 * Constraint:
	 *     speed=EDouble?
	 * </pre>
	 */
	protected void sequence_SpeedCommand(ISerializationContext context, SpeedCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns TimeSensorCommand
	 *     TimeSensorCommand returns TimeSensorCommand
	 *
	 * Constraint:
	 *     {TimeSensorCommand}
	 * </pre>
	 */
	protected void sequence_TimeSensorCommand(ISerializationContext context, TimeSensorCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns Time
	 *     Time returns Time
	 *
	 * Constraint:
	 *     value=EDouble?
	 * </pre>
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns mm
	 *     Distance returns mm
	 *     mm returns mm
	 *
	 * Constraint:
	 *     distance=EDouble?
	 * </pre>
	 */
	protected void sequence_mm(ISerializationContext context, mm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
