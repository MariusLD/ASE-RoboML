/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;
import robot.Affectation;
import robot.And;
import robot.ArithmetiqueExp;
import robot.BooleanExp;
import robot.BooleanType;
import robot.CM;
import robot.CallFunction;
import robot.CallVariable;
import robot.Div;
import robot.Equals;
import robot.Minus;
import robot.Mult;
import robot.Not;
import robot.NumberType;
import robot.Or;
import robot.Plus;
import robot.PrimaryExprAri;
import robot.PrimaryExprBool;
import robot.RobotPackage;
import robot.SecondaryExpAri;
import robot.SecondaryExpBool;
import robot.mm;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotPackage.AFFECTATION:
				sequence_Affectation(context, (Affectation) semanticObject); 
				return; 
			case RobotPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobotPackage.ARITHMETIQUE_EXP:
				sequence_ArithmetiqueExp_Impl(context, (ArithmetiqueExp) semanticObject); 
				return; 
			case RobotPackage.BOOLEAN_EXP:
				sequence_BooleanExp_Impl(context, (BooleanExp) semanticObject); 
				return; 
			case RobotPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case RobotPackage.CM:
				sequence_CM(context, (CM) semanticObject); 
				return; 
			case RobotPackage.CALL_FUNCTION:
				sequence_CallFunction(context, (CallFunction) semanticObject); 
				return; 
			case RobotPackage.CALL_VARIABLE:
				sequence_CallVariable(context, (CallVariable) semanticObject); 
				return; 
			case RobotPackage.DIV:
				sequence_Div(context, (Div) semanticObject); 
				return; 
			case RobotPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case RobotPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case RobotPackage.MULT:
				sequence_Mult(context, (Mult) semanticObject); 
				return; 
			case RobotPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case RobotPackage.NUMBER_TYPE:
				sequence_NumberType(context, (NumberType) semanticObject); 
				return; 
			case RobotPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobotPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case RobotPackage.PRIMARY_EXPR_ARI:
				sequence_PrimaryExprAri(context, (PrimaryExprAri) semanticObject); 
				return; 
			case RobotPackage.PRIMARY_EXPR_BOOL:
				sequence_PrimaryExprBool(context, (PrimaryExprBool) semanticObject); 
				return; 
			case RobotPackage.SECONDARY_EXP_ARI:
				sequence_SecondaryExpAri_Impl(context, (SecondaryExpAri) semanticObject); 
				return; 
			case RobotPackage.SECONDARY_EXP_BOOL:
				sequence_SecondaryExpBool_Impl(context, (SecondaryExpBool) semanticObject); 
				return; 
			case RobotPackage.MM:
				sequence_mm(context, (mm) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Affectation returns Affectation
	 *     ExpressionBase returns Affectation
	 *
	 * Constraint:
	 *     (expressionbase+=ExpressionBase expressionbase+=ExpressionBase* callvariable=CallVariable?)
	 * </pre>
	 */
	protected void sequence_Affectation(ISerializationContext context, Affectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns And
	 *     BooleanExp returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (right+=BooleanExp right+=BooleanExp* left=BooleanExp)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns ArithmetiqueExp
	 *     ArithmetiqueExp returns ArithmetiqueExp
	 *     ArithmetiqueExp_Impl returns ArithmetiqueExp
	 *
	 * Constraint:
	 *     {ArithmetiqueExp}
	 * </pre>
	 */
	protected void sequence_ArithmetiqueExp_Impl(ISerializationContext context, ArithmetiqueExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns BooleanExp
	 *     BooleanExp returns BooleanExp
	 *     BooleanExp_Impl returns BooleanExp
	 *
	 * Constraint:
	 *     {BooleanExp}
	 * </pre>
	 */
	protected void sequence_BooleanExp_Impl(ISerializationContext context, BooleanExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     value?='value'?
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns CM
	 *     CM returns CM
	 *
	 * Constraint:
	 *     distance=EDouble?
	 * </pre>
	 */
	protected void sequence_CM(ISerializationContext context, CM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns CallFunction
	 *     Call returns CallFunction
	 *     CallFunction returns CallFunction
	 *
	 * Constraint:
	 *     {CallFunction}
	 * </pre>
	 */
	protected void sequence_CallFunction(ISerializationContext context, CallFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns CallVariable
	 *     Call returns CallVariable
	 *     CallVariable returns CallVariable
	 *
	 * Constraint:
	 *     {CallVariable}
	 * </pre>
	 */
	protected void sequence_CallVariable(ISerializationContext context, CallVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Div
	 *     ArithmetiqueExp returns Div
	 *     Div returns Div
	 *
	 * Constraint:
	 *     (right+=ArithmetiqueExp right+=ArithmetiqueExp* left=ArithmetiqueExp)
	 * </pre>
	 */
	protected void sequence_Div(ISerializationContext context, Div semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Equals
	 *     BooleanExp returns Equals
	 *     Equals returns Equals
	 *
	 * Constraint:
	 *     (right+=BooleanExp right+=BooleanExp* left=BooleanExp)
	 * </pre>
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Minus
	 *     ArithmetiqueExp returns Minus
	 *     Minus returns Minus
	 *
	 * Constraint:
	 *     (right+=ArithmetiqueExp right+=ArithmetiqueExp* left=ArithmetiqueExp)
	 * </pre>
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Mult
	 *     ArithmetiqueExp returns Mult
	 *     Mult returns Mult
	 *
	 * Constraint:
	 *     (right+=ArithmetiqueExp right+=ArithmetiqueExp* left=ArithmetiqueExp)
	 * </pre>
	 */
	protected void sequence_Mult(ISerializationContext context, Mult semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Not
	 *     BooleanExp returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     (right+=BooleanExp right+=BooleanExp* left=BooleanExp)
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns NumberType
	 *     NumberType returns NumberType
	 *
	 * Constraint:
	 *     value=EDouble?
	 * </pre>
	 */
	protected void sequence_NumberType(ISerializationContext context, NumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Or
	 *     BooleanExp returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (right+=BooleanExp right+=BooleanExp* left=BooleanExp)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns Plus
	 *     ArithmetiqueExp returns Plus
	 *     Plus returns Plus
	 *
	 * Constraint:
	 *     (right+=ArithmetiqueExp right+=ArithmetiqueExp* left=ArithmetiqueExp)
	 * </pre>
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns PrimaryExprAri
	 *     ArithmetiqueExp returns PrimaryExprAri
	 *     PrimaryExprAri returns PrimaryExprAri
	 *
	 * Constraint:
	 *     (type=TypeClass? call=Call?)
	 * </pre>
	 */
	protected void sequence_PrimaryExprAri(ISerializationContext context, PrimaryExprAri semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns PrimaryExprBool
	 *     BooleanExp returns PrimaryExprBool
	 *     PrimaryExprBool returns PrimaryExprBool
	 *
	 * Constraint:
	 *     (type=TypeClass? call=Call?)
	 * </pre>
	 */
	protected void sequence_PrimaryExprBool(ISerializationContext context, PrimaryExprBool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns SecondaryExpAri
	 *     ArithmetiqueExp returns SecondaryExpAri
	 *     SecondaryExpAri_Impl returns SecondaryExpAri
	 *
	 * Constraint:
	 *     (right+=ArithmetiqueExp right+=ArithmetiqueExp* left=ArithmetiqueExp)
	 * </pre>
	 */
	protected void sequence_SecondaryExpAri_Impl(ISerializationContext context, SecondaryExpAri semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionBase returns SecondaryExpBool
	 *     BooleanExp returns SecondaryExpBool
	 *     SecondaryExpBool_Impl returns SecondaryExpBool
	 *
	 * Constraint:
	 *     (right+=BooleanExp right+=BooleanExp* left=BooleanExp)
	 * </pre>
	 */
	protected void sequence_SecondaryExpBool_Impl(ISerializationContext context, SecondaryExpBool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeClass returns mm
	 *     mm returns mm
	 *
	 * Constraint:
	 *     distance=EDouble?
	 * </pre>
	 */
	protected void sequence_mm(ISerializationContext context, mm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
